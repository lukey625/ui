#!/usr/bin/env python3
"""
Phoenix Pro Elite - Phase 2C: Live Features & Monitoring
Adds live alerts, WebSocket auto-reconnect, real-time monitoring
Run this AFTER Phase 2B is working
"""

import os
import sys
import json
from datetime import datetime
from pathlib import Path

# Configuration
PHOENIX_DIR = Path("/root/phoenix-pro-elite")
UI_FILE = PHOENIX_DIR / "ui" / "app.py"

def backup_ui_file():
    """Backup the current UI file"""
    if UI_FILE.exists():
        backup_file = UI_FILE.parent / f"app_backup_phase2b_{datetime.now().strftime('%Y%m%d_%H%M%S')}.py"
        import shutil
        shutil.copy2(UI_FILE, backup_file)
        print(f"‚úÖ Backed up Phase 2B UI to: {backup_file}")
        return True
    else:
        print("‚ùå UI file not found. Please run previous phases first.")
        return False

def create_live_features_code():
    """Create the live features code to add"""
    return '''
# ============================================================================
# PHASE 2C ADDITIONS: LIVE FEATURES & MONITORING
# ============================================================================

import threading
import time
from datetime import datetime, timedelta

# Enhanced Live Features UI State
class LiveFeaturesUIState(APIIntegratedUIState):
    def __init__(self):
        super().__init__()
        self.websocket_clients = set()
        self.monitoring_active = True
        self.auto_reconnect_enabled = True
        self.last_heartbeat = datetime.now()
        self.system_alerts_enabled = True
        self.performance_baseline = {
            'cpu_threshold': 85,
            'memory_threshold': 90,
            'disk_threshold': 95,
            'response_time_threshold': 5000  # ms
        }
        self.start_monitoring_threads()
    
    def start_monitoring_threads(self):
        """Start background monitoring threads"""
        if self.monitoring_active:
            # System monitoring thread
            system_thread = threading.Thread(target=self._system_monitoring_loop, daemon=True)
            system_thread.start()
            
            # Bot health monitoring thread
            bot_thread = threading.Thread(target=self._bot_health_monitoring_loop, daemon=True)
            bot_thread.start()
            
            # WebSocket health monitoring
            ws_thread = threading.Thread(target=self._websocket_health_loop, daemon=True)
            ws_thread.start()
            
            logger.info("Live monitoring threads started")
    
    def _system_monitoring_loop(self):
        """Background system monitoring loop"""
        while self.monitoring_active:
            try:
                # Get system metrics
                cpu_usage = psutil.cpu_percent(interval=1)
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('/')
                
                # Update system status
                self.system_status.update({
                    'cpu_usage': cpu_usage,
                    'memory_usage': memory.percent,
                    'disk_usage': (disk.used / disk.total) * 100,
                    'uptime': time.time() - psutil.boot_time()
                })
                
                # Check for alerts
                if cpu_usage > self.performance_baseline['cpu_threshold']:
                    self.add_alert('warning', f'High CPU usage: {cpu_usage:.1f}%', category='performance')
                
                if memory.percent > self.performance_baseline['memory_threshold']:
                    self.add_alert('warning', f'High memory usage: {memory.percent:.1f}%', category='performance')
                
                if (disk.used / disk.total) * 100 > self.performance_baseline['disk_threshold']:
                    self.add_alert('critical', f'High disk usage: {(disk.used / disk.total) * 100:.1f}%', category='system')
                
                # Store metrics in database
                cursor = self.db_connection.cursor()
                cursor.execute("""
                    INSERT INTO system_metrics (cpu_usage, memory_usage, disk_usage, active_connections)
                    VALUES (?, ?, ?, ?)
                """, (cpu_usage, memory.percent, (disk.used / disk.total) * 100, len(self.websocket_clients)))
                self.db_connection.commit()
                
                # Emit to WebSocket clients
                socketio.emit('system_update', {
                    'cpu_usage': cpu_usage,
                    'memory_usage': memory.percent,
                    'disk_usage': (disk.used / disk.total) * 100,
                    'timestamp': datetime.now().isoformat()
                })
                
            except Exception as e:
                logger.error(f"System monitoring error: {e}")
            
            time.sleep(30)  # Check every 30 seconds
    
    def _bot_health_monitoring_loop(self):
        """Background bot health monitoring loop"""
        while self.monitoring_active:
            try:
                for bot_id, bot_data in self.bots.items():
                    # Simulate bot health checks
                    health_score = self._calculate_bot_health(bot_data)
                    
                    # Store bot health in database
                    cursor = self.db_connection.cursor()
                    cursor.execute("""
                        INSERT INTO bot_health (bot_id, status, performance_score, uptime, profit_loss)
                        VALUES (?, ?, ?, ?, ?)
                    """, (bot_id, 'active' if bot_data['active'] else 'inactive', 
                          health_score, bot_data.get('uptime', 0), bot_data.get('pnl_24h', 0)))
                    self.db_connection.commit()
                    
                    # Check for bot issues
                    if health_score < 0.5 and bot_data['active']:
                        self.add_alert('warning', f'Bot {bot_data["name"]} health degraded: {health_score:.1%}', 
                                     bot_id=bot_id, category='bot_health')
                    
                    if bot_data.get('error_count', 0) > 5:
                        self.add_alert('error', f'Bot {bot_data["name"]} has {bot_data["error_count"]} errors', 
                                     bot_id=bot_id, category='bot_health')
                
                # Emit bot updates to WebSocket clients
                socketio.emit('bots_update', self.bots)
                
            except Exception as e:
                logger.error(f"Bot health monitoring error: {e}")
            
            time.sleep(60)  # Check every minute
    
    def _websocket_health_loop(self):
        """Monitor WebSocket connection health"""
        while self.monitoring_active:
            try:
                # Update heartbeat
                self.last_heartbeat = datetime.now()
                
                # Send heartbeat to all clients
                socketio.emit('heartbeat', {
                    'timestamp': self.last_heartbeat.isoformat(),
                    'server_status': 'healthy',
                    'active_connections': len(self.websocket_clients)
                })
                
                # Check for stale connections
                current_time = datetime.now()
                if hasattr(self, 'websocket_health'):
                    if self.websocket_health.get('last_heartbeat'):
                        time_since_last = current_time - datetime.fromisoformat(self.websocket_health['last_heartbeat'])
                        if time_since_last > timedelta(minutes=5):
                            self.add_alert('warning', 'WebSocket connection may be stale', category='websocket')
                
                self.websocket_health.update({
                    'last_heartbeat': current_time.isoformat(),
                    'active_connections': len(self.websocket_clients),
                    'status': 'healthy'
                })
                
            except Exception as e:
                logger.error(f"WebSocket health monitoring error: {e}")
            
            time.sleep(30)  # Heartbeat every 30 seconds
    
    def _calculate_bot_health(self, bot_data):
        """Calculate bot health score (0-1)"""
        score = 1.0
        
        # Deduct for errors
        error_count = bot_data.get('error_count', 0)
        score -= min(error_count * 0.1, 0.5)
        
        # Deduct for low win rate
        win_rate = bot_data.get('win_rate', 0.5)
        if win_rate < 0.3:
            score -= 0.3
        elif win_rate < 0.5:
            score -= 0.1
        
        # Deduct for negative P&L
        pnl_24h = bot_data.get('pnl_24h', 0)
        if pnl_24h < -100:
            score -= 0.2
        elif pnl_24h < 0:
            score -= 0.1
        
        # Boost for high uptime
        uptime = bot_data.get('uptime', 0)
        if uptime > 99:
            score += 0.1
        
        return max(0, min(1, score))
    
    def add_alert(self, level: str, message: str, bot_id: str = None, category: str = 'general'):
        """Enhanced alert system with live broadcast"""
        try:
            # Call parent method
            super().add_alert(level, message, bot_id, category)
            
            # Broadcast alert to all WebSocket clients
            alert_data = {
                'level': level,
                'message': message,
                'bot_id': bot_id,
                'category': category,
                'timestamp': datetime.now().isoformat()
            }
            
            socketio.emit('new_alert', alert_data)
            
            # Auto-recovery for critical alerts
            if level == 'critical' and self.auto_reconnect_enabled:
                self._trigger_auto_recovery(message, bot_id)
            
        except Exception as e:
            logger.error(f"Enhanced alert error: {e}")
    
    def _trigger_auto_recovery(self, message: str, bot_id: str = None):
        """Trigger automated recovery procedures"""
        try:
            logger.warning(f"Auto-recovery triggered: {message}")
            
            # Bot-specific recovery
            if bot_id and bot_id in self.bots:
                bot_data = self.bots[bot_id]
                if bot_data.get('error_count', 0) > 10:
                    # Simulate bot restart
                    self.add_alert('info', f'Auto-restarting bot {bot_data["name"]}', bot_id=bot_id, category='recovery')
                    bot_data['error_count'] = 0
                    bot_data['last_restart'] = datetime.now().isoformat()
            
            # System-wide recovery
            if 'disk usage' in message.lower():
                self.add_alert('info', 'Triggering disk cleanup procedures', category='recovery')
                # In real implementation, trigger cleanup scripts
            
            if 'memory usage' in message.lower():
                self.add_alert('info', 'Triggering memory optimization', category='recovery')
                # In real implementation, trigger memory cleanup
            
        except Exception as e:
            logger.error(f"Auto-recovery error: {e}")

# Enhanced Socket.IO Events
@socketio.on('connect')
def handle_connect():
    logger.info(f'Client connected: {request.sid}')
    ui_state.websocket_clients.add(request.sid)
    emit('connected', {
        'status': 'Connected to Phoenix Pro Elite',
        'server_time': datetime.now().isoformat(),
        'features': {
            'live_alerts': True,
            'auto_reconnect': True,
            'real_time_monitoring': True
        }
    })
    
    # Send current system status
    emit('system_update', ui_state.system_status)
    emit('bots_update', ui_state.bots)

@socketio.on('disconnect')
def handle_disconnect():
    logger.info(f'Client disconnected: {request.sid}')
    ui_state.websocket_clients.discard(request.sid)

@socketio.on('ping')
def handle_ping():
    emit('pong', {'timestamp': datetime.now().isoformat()})

@socketio.on('request_system_update')
def handle_system_update_request():
    emit('system_update', ui_state.system_status)

@socketio.on('request_bots_update')
def handle_bots_update_request():
    emit('bots_update', ui_state.bots)

@socketio.on('acknowledge_alert')
def handle_acknowledge_alert(data):
    alert_id = data.get('alert_id')
    if alert_id:
        try:
            cursor = ui_state.db_connection.cursor()
            cursor.execute("UPDATE alerts SET acknowledged = TRUE WHERE id = ?", (alert_id,))
            ui_state.db_connection.commit()
            emit('alert_acknowledged', {'alert_id': alert_id})
        except Exception as e:
            emit('error', {'message': str(e)})

# Enhanced Live Monitoring Routes
@app.route('/api/ui/alerts/live')
def get_live_alerts():
    """Get live alerts with real-time status"""
    try:
        cursor = ui_state.db_connection.cursor()
        cursor.execute("""
            SELECT id, timestamp, level, message, bot_id, acknowledged, category
            FROM alerts 
            WHERE timestamp > datetime('now', '-1 hour')
            ORDER BY timestamp DESC 
        """)
        
        alerts = []
        for row in cursor.fetchall():
            alerts.append({
                'id': row[0],
                'timestamp': row[1],
                'level': row[2],
                'message': row[3],
                'bot_id': row[4],
                'acknowledged': bool(row[5]),
                'category': row[6]
            })
        
        return jsonify({
            'alerts': alerts,
            'total_count': len(alerts),
            'server_time': datetime.now().isoformat(),
            'monitoring_status': 'active' if ui_state.monitoring_active else 'inactive'
        })
    except Exception as e:
        return jsonify({'error': str(e)})

@app.route('/api/ui/monitoring/status')
def get_monitoring_status():
    """Get comprehensive monitoring status"""
    try:
        return jsonify({
            'monitoring_active': ui_state.monitoring_active,
            'auto_reconnect_enabled': ui_state.auto_reconnect_enabled,
            'websocket_health': ui_state.websocket_health,
            'active_connections': len(ui_state.websocket_clients),
            'last_heartbeat': ui_state.last_heartbeat.isoformat(),
            'system_status': ui_state.system_status,
            'performance_baseline': ui_state.performance_baseline,
            'uptime': time.time() - psutil.boot_time() if hasattr(psutil, 'boot_time') else 0
        })
    except Exception as e:
        return jsonify({'error': str(e)})

@app.route('/api/ui/monitoring/toggle', methods=['POST'])
def toggle_monitoring():
    """Toggle monitoring on/off"""
    try:
        data = request.json
        new_status = data.get('enabled', not ui_state.monitoring_active)
        ui_state.monitoring_active = new_status
        
        if new_status:
            ui_state.add_alert('info', 'Live monitoring enabled', category='system')
        else:
            ui_state.add_alert('warning', 'Live monitoring disabled', category='system')
        
        return jsonify({
            'status': 'success',
            'monitoring_active': ui_state.monitoring_active
        })
    except Exception as e:
        return jsonify({'error': str(e)})

@app.route('/api/ui/recovery/trigger', methods=['POST'])
def trigger_manual_recovery():
    """Manually trigger recovery procedures"""
    try:
        data = request.json
        recovery_type = data.get('type', 'general')
        
        if recovery_type == 'bot_restart':
            bot_id = data.get('bot_id')
            if bot_id and bot_id in ui_state.bots:
                ui_state._trigger_auto_recovery(f'Manual recovery for bot {bot_id}', bot_id)
                return jsonify({'status': 'success', 'message': f'Recovery triggered for bot {bot_id}'})
        
        elif recovery_type == 'system_cleanup':
            ui_state._trigger_auto_recovery('Manual system cleanup', None)
            return jsonify({'status': 'success', 'message': 'System cleanup recovery triggered'})
        
        elif recovery_type == 'websocket_reset':
            ui_state.websocket_clients.clear()
            ui_state.add_alert('info', 'WebSocket connections reset', category='recovery')
            return jsonify({'status': 'success', 'message': 'WebSocket connections reset'})
        
        else:
            return jsonify({'error': 'Unknown recovery type'})
            
    except Exception as e:
        return jsonify({'error': str(e)})

@app.route('/api/ui/performance/baseline', methods=['GET', 'POST'])
def handle_performance_baseline():
    """Get or update performance baseline settings"""
    if request.method == 'GET':
        return jsonify(ui_state.performance_baseline)
    else:
        try:
            data = request.json
            ui_state.performance_baseline.update(data)
            ui_state.add_alert('info', 'Performance baseline updated', category='settings')
            return jsonify({'status': 'success', 'baseline': ui_state.performance_baseline})
        except Exception as e:
            return jsonify({'error': str(e)})

'''

def create_enhanced_html_live_features():
    """Create enhanced HTML for live features"""
    return '''
        <!-- Live Alerts Banner -->
        <div id="alertsBanner" class="alerts-banner" style="display: none;">
            <div class="alerts-content">
                <span class="alerts-icon">üîî</span>
                <span id="alertsText">System monitoring active</span>
                <button class="btn btn-blue alerts-btn" onclick="toggleAlertsPanel()">
                    Alerts (<span id="alertsCount">0</span>)
                </button>
            </div>
        </div>
        
        <!-- Live Alerts Panel -->
        <div id="alertsPanel" class="alerts-panel">
            <div class="alerts-header">
                <h3>üîî Live System Alerts</h3>
                <div>
                    <button class="btn btn-sm" onclick="clearAllAlerts()">Clear All</button>
                    <button class="btn btn-sm" onclick="toggleAlertsPanel()">√ó</button>
                </div>
            </div>
            <div class="alerts-list" id="alertsList">
                <!-- Alerts will be populated here -->
            </div>
        </div>
        
        <!-- Live Status Indicators -->
        <div id="liveStatusBar" class="live-status-bar">
            <div class="status-item">
                <span class="status-label">WebSocket:</span>
                <span id="wsStatus" class="status-indicator status-disconnected">‚óè</span>
            </div>
            <div class="status-item">
                <span class="status-label">Monitoring:</span>
                <span id="monitoringStatus" class="status-indicator status-connected">‚óè</span>
            </div>
            <div class="status-item">
                <span class="status-label">Auto-Recovery:</span>
                <span id="recoveryStatus" class="status-indicator status-connected">‚óè</span>
            </div>
            <div class="status-item">
                <span class="status-label">Last Update:</span>
                <span id="lastUpdate">--:--</span>
            </div>
        </div>

        <!-- Enhanced CSS for Live Features -->
        <style>
        .alerts-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            padding: 12px 20px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.3s ease;
        }
        
        .alerts-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .alerts-icon {
            font-size: 18px;
            animation: pulse 2s infinite;
        }
        
        .alerts-btn {
            padding: 8px 16px;
            font-size: 14px;
        }
        
        .alerts-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 400px;
            max-height: 600px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            overflow: hidden;
            transform: translateX(420px);
            transition: transform 0.3s ease;
        }
        
        .alerts-panel.show {
            transform: translateX(0);
        }
        
        .alerts-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .alerts-list {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .alert-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.2s;
        }
        
        .alert-item:hover {
            background: var(--bg-tertiary);
        }
        
        .alert-level {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        
        .alert-critical { color: var(--accent-red); }
        .alert-error { color: var(--accent-red); }
        .alert-warning { color: var(--accent-yellow); }
        .alert-info { color: var(--accent-blue); }
        .alert-success { color: var(--accent-green); }
        
        .live-status-bar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 16px;
            display: flex;
            gap: 16px;
            font-size: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .status-label {
            color: var(--text-secondary);
        }
        
        @keyframes slideDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .monitoring-controls {
            display: flex;
            gap: 12px;
            margin: 20px 0;
        }
        
        .recovery-section {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        </style>

        <!-- Enhanced JavaScript for Live Features -->
        <script>
        let socket = io();
        let alertsPanel = document.getElementById('alertsPanel');
        let alertsPanelVisible = false;
        let lastHeartbeat = null;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 10;
        
        // Enhanced Socket.IO with auto-reconnect
        function connectSocketIO() {
            socket.on('connect', function() {
                console.log('Connected to Phoenix Live');
                document.getElementById('wsStatus').className = 'status-indicator status-connected';
                showNotification('Phoenix Live Connected ‚úÖ', 'success');
                reconnectAttempts = 0;
                
                // Request initial data
                socket.emit('request_system_update');
                socket.emit('request_bots_update');
            });
            
            socket.on('disconnect', function() {
                console.log('Disconnected from Phoenix');
                document.getElementById('wsStatus').className = 'status-indicator status-disconnected';
                showNotification('Connection lost - attempting reconnect...', 'warning');
                attemptReconnect();
            });
            
            socket.on('system_update', function(data) {
                updateSystemMetrics(data);
                updateLastUpdateTime();
            });
            
            socket.on('bots_update', function(data) {
                updateBotsDisplay(data);
            });
            
            socket.on('new_alert', function(alert) {
                addLiveAlert(alert);
                updateAlertsCount();
            });
            
            socket.on('heartbeat', function(data) {
                lastHeartbeat = new Date(data.timestamp);
                updateLastUpdateTime();
            });
            
            socket.on('error', function(error) {
                console.error('Socket error:', error);
                showNotification('WebSocket error: ' + error.message, 'error');
            });
            
            // Ping/pong for connection health
            setInterval(function() {
                if (socket.connected) {
                    socket.emit('ping');
                }
            }, 30000);
            
            socket.on('pong', function(data) {
                lastHeartbeat = new Date(data.timestamp);
            });
        }
        
        function attemptReconnect() {
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                setTimeout(function() {
                    console.log(`Reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts}`);
                    socket.connect();
                }, 2000 * reconnectAttempts); // Exponential backoff
            } else {
                showNotification('Max reconnection attempts reached. Please refresh.', 'error');
                document.getElementById('wsStatus').className = 'status-indicator status-disconnected';
            }
        }
        
        function updateSystemMetrics(data) {
            // Update metric cards
            document.getElementById('systemHealth').textContent = 
                Math.max(0, 100 - Math.max(data.cpu_usage || 0, data.memory_usage || 0, data.disk_usage || 0)).toFixed(0) + '%';
            
            // Update system health color
            const healthValue = 100 - Math.max(data.cpu_usage || 0, data.memory_usage || 0, data.disk_usage || 0);
            const healthElement = document.getElementById('systemHealth');
            if (healthValue < 70) {
                healthElement.className = 'metric-value negative';
            } else {
                healthElement.className = 'metric-value positive';
            }
        }
        
        function updateBotsDisplay(botsData) {
            // Update active bots count
            const activeBots = Object.values(botsData).filter(bot => bot.active).length;
            document.getElementById('activeBots').textContent = activeBots;
            
            // Update bot grid if visible
            const botGrid = document.getElementById('botGrid');
            if (botGrid && document.getElementById('bots').classList.contains('active')) {
                loadBots(); // Refresh the bots display
            }
        }
        
        function addLiveAlert(alert) {
            const alertsList = document.getElementById('alertsList');
            const alertElement = document.createElement('div');
            alertElement.className = 'alert-item';
            alertElement.innerHTML = `
                <div class="alert-level alert-${alert.level}">${alert.level.toUpperCase()}</div>
                <div class="alert-message">${alert.message}</div>
                <div class="alert-time">${new Date(alert.timestamp).toLocaleTimeString()}</div>
                ${alert.bot_id ? `<div class="alert-bot">Bot: ${alert.bot_id}</div>` : ''}
                <button onclick="acknowledgeAlert(${alert.id || 'temp'})" class="btn btn-sm" style="margin-top: 8px;">
                    Acknowledge
                </button>
            `;
            
            alertsList.insertBefore(alertElement, alertsList.firstChild);
            
            // Show alerts banner if hidden
            document.getElementById('alertsBanner').style.display = 'block';
            
            // Auto-show critical alerts
            if (alert.level === 'critical' || alert.level === 'error') {
                if (!alertsPanelVisible) {
                    toggleAlertsPanel();
                }
            }
        }
        
        function updateAlertsCount() {
            fetch('/api/ui/alerts/live')
                .then(response => response.json())
                .then(data => {
                    const unacknowledged = data.alerts.filter(a => !a.acknowledged).length;
                    document.getElementById('alertsCount').textContent = unacknowledged;
                    
                    if (unacknowledged > 0) {
                        document.getElementById('alertsBanner').style.display = 'block';
                        document.getElementById('alertsText').textContent = 
                            `${unacknowledged} active alert${unacknowledged > 1 ? 's' : ''}`;
                    } else {
                        document.getElementById('alertsText').textContent = 'System monitoring active';
                    }
                })
                .catch(err => console.error('Error updating alerts count:', err));
        }
        
        function updateLastUpdateTime() {
            const now = new Date();
            document.getElementById('lastUpdate').textContent = now.toLocaleTimeString();
        }
        
        function toggleAlertsPanel() {
            alertsPanelVisible = !alertsPanelVisible;
            alertsPanel.classList.toggle('show', alertsPanelVisible);
            
            if (alertsPanelVisible) {
                loadAlertsHistory();
            }
        }
        
        async function loadAlertsHistory() {
            try {
                const response = await fetch('/api/ui/alerts/live');
                const data = await response.json();
                
                const alertsList = document.getElementById('alertsList');
                alertsList.innerHTML = '';
                
                data.alerts.forEach(alert => {
                    const alertEl = document.createElement('div');
                    alertEl.className = 'alert-item' + (alert.acknowledged ? ' acknowledged' : '');
                    alertEl.innerHTML = `
                        <div class="alert-level alert-${alert.level}">${alert.level.toUpperCase()}</div>
                        <div class="alert-message">${alert.message}</div>
                        <div class="alert-time">${new Date(alert.timestamp).toLocaleString()}</div>
                        ${alert.bot_id ? `<div class="alert-bot">Bot: ${alert.bot_id}</div>` : ''}
                        ${!alert.acknowledged ? 
                            `<button onclick="acknowledgeAlert(${alert.id})" class="btn btn-sm" style="margin-top: 8px;">Acknowledge</button>` : 
                            '<span style="color: var(--accent-green); font-size: 12px;">‚úì Acknowledged</span>'
                        }
                    `;
                    alertsList.appendChild(alertEl);
                });
            } catch (err) {
                console.error('Error loading alerts:', err);
            }
        }
        
        async function acknowledgeAlert(alertId) {
            try {
                socket.emit('acknowledge_alert', { alert_id: alertId });
                showNotification('Alert acknowledged', 'success');
                loadAlertsHistory();
                updateAlertsCount();
            } catch (err) {
                console.error('Error acknowledging alert:', err);
            }
        }
        
        async function clearAllAlerts() {
            if (confirm('Clear all acknowledged alerts?')) {
                try {
                    await fetch('/api/ui/alerts/clear_all', { method: 'POST' });
                    loadAlertsHistory();
                    updateAlertsCount();
                    showNotification('Alerts cleared', 'success');
                } catch (err) {
                    console.error('Error clearing alerts:', err);
                }
            }
        }
        
        // Monitoring controls
        async function toggleMonitoring() {
            try {
                const response = await fetch('/api/ui/monitoring/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                const result = await response.json();
                
                if (result.error) {
                    showNotification('Failed to toggle monitoring: ' + result.error, 'error');
                } else {
                    const status = result.monitoring_active ? 'enabled' : 'disabled';
                    showNotification(`Monitoring ${status}`, 'success');
                    document.getElementById('monitoringStatus').className = 
                        'status-indicator ' + (result.monitoring_active ? 'status-connected' : 'status-disconnected');
                }
            } catch (err) {
                showNotification('Error toggling monitoring', 'error');
            }
        }
        
        // Emergency recovery functions
        async function triggerRecovery(type, botId = null) {
            try {
                const response = await fetch('/api/ui/recovery/trigger', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ type: type, bot_id: botId })
                });
                
                const result = await response.json();
                
                if (result.error) {
                    showNotification('Recovery failed: ' + result.error, 'error');
                } else {
                    showNotification(result.message, 'success');
                }
            } catch (err) {
                showNotification('Recovery error', 'error');
            }
        }
        
        // Initialize live features
        document.addEventListener('DOMContentLoaded', function() {
            connectSocketIO();
            updateAlertsCount();
            
            // Update monitoring status
            fetch('/api/ui/monitoring/status')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('monitoringStatus').className = 
                        'status-indicator ' + (data.monitoring_active ? 'status-connected' : 'status-disconnected');
                    document.getElementById('recoveryStatus').className = 
                        'status-indicator ' + (data.auto_reconnect_enabled ? 'status-connected' : 'status-disconnected');
                })
                .catch(err => console.error('Error loading monitoring status:', err));
            
            // Regular updates
            setInterval(updateAlertsCount, 30000);
            setInterval(updateLastUpdateTime, 1000);
        });
        </script>
    '''

def modify_ui_file_for_live_features():
    """Modify the UI file to add live features"""
    with open(UI_FILE, 'r') as f:
        content = f.read()
    
    # Check for required previous phases
    if "class APIIntegratedUIState" not in content:
        print("‚ùå Phase 2B components not found!")
        print("   Please run Phase 2B first to add API integrations")
        return False
    
    # Add live features code
    live_features_code = create_live_features_code()
    routes_pos = content.find("# Flask Routes") or content.find("@app.route('/')")
    
    if routes_pos == -1:
        print("‚ùå Could not find Flask routes section")
        return False
    
    # Insert live features code
    new_content = content[:routes_pos] + live_features_code + "\n" + content[routes_pos:]
    
    # Replace ui_state initialization
    old_init = "ui_state = APIIntegratedUIState()"
    new_init = "ui_state = LiveFeaturesUIState()"
    new_content = new_content.replace(old_init, new_init)
    
    # Add live features HTML
    html_template_start = new_content.find('HTML_TEMPLATE = \'\'\'')
    if html_template_start != -1:
        # Find the container div and add live features
        container_start = new_content.find('<div class="container">')
        if container_start != -1:
            enhanced_html = create_enhanced_html_live_features()
            # Insert after the container opening tag
            insert_pos = new_content.find('>', container_start) + 1
            new_content = new_content[:insert_pos] + '\n' + enhanced_html + new_content[insert_pos:]
    
    # Write the modified content
    with open(UI_FILE, 'w') as f:
        f.write(new_content)
    
    return True

def add_monitoring_tab():
    """Add monitoring tab to the UI"""
    with open(UI_FILE, 'r') as f:
        content = f.read()
    
    # Add monitoring tab
    ai_tab = content.find('<button class="tab" onclick="showTab(\'ai\')">üß† AI</button>')
    if ai_tab != -1:
        monitoring_tab = '<button class="tab" onclick="showTab(\'monitoring\')">üìä Monitoring</button>\n            '
        content = content[:ai_tab] + monitoring_tab + content[ai_tab:]
    
    # Add monitoring tab content
    monitoring_content = '''
        <div id="monitoring" class="tab-content">
            <h2 class="panel-title">üìä Live System Monitoring</h2>
            
            <div class="monitoring-controls">
                <button class="btn btn-blue" onclick="toggleMonitoring()">Toggle Monitoring</button>
                <button class="btn btn-green" onclick="location.reload()">Refresh Dashboard</button>
                <button class="btn btn-yellow" onclick="triggerRecovery('system_cleanup')">System Cleanup</button>
                <button class="btn btn-purple" onclick="triggerRecovery('websocket_reset')">Reset Connections</button>
            </div>
            
            <div class="api-section">
                <h3>System Performance</h3>
                <div class="bot-grid">
                    <div class="bot-card">
                        <div class="bot-header">
                            <div class="bot-name">CPU Usage</div>
                            <div class="bot-status" id="cpuStatus">--</div>
                        </div>
                        <div class="bot-metrics">
                            <div class="bot-metric">
                                <div class="bot-metric-label">Current</div>
                                <div class="bot-metric-value" id="cpuCurrent">--%</div>
                            </div>
                            <div class="bot-metric">
                                <div class="bot-metric-label">Threshold</div>
                                <div class="bot-metric-value">85%</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bot-card">
                        <div class="bot-header">
                            <div class="bot-name">Memory Usage</div>
                            <div class="bot-status" id="memoryStatus">--</div>
                        </div>
                        <div class="bot-metrics">
                            <div class="bot-metric">
                                <div class="bot-metric-label">Current</div>
                                <div class="bot-metric-value" id="memoryCurrent">--%</div>
                            </div>
                            <div class="bot-metric">
                                <div class="bot-metric-label">Threshold</div>
                                <div class="bot-metric-value">90%</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bot-card">
                        <div class="bot-header">
                            <div class="bot-name">WebSocket Health</div>
                            <div class="bot-status" id="wsHealthStatus">--</div>
                        </div>
                        <div class="bot-metrics">
                            <div class="bot-metric">
                                <div class="bot-metric-label">Connections</div>
                                <div class="bot-metric-value" id="wsConnections">0</div>
                            </div>
                            <div class="bot-metric">
                                <div class="bot-metric-label">Last Heartbeat</div>
                                <div class="bot-metric-value" id="wsHeartbeat">--</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="recovery-section">
                <h3>üö® Emergency Recovery</h3>
                <p>Use these controls if the system becomes unresponsive:</p>
                <div class="monitoring-controls">
                    <button class="btn btn-red" onclick="triggerRecovery('bot_restart', 'all')">Restart All Bots</button>
                    <button class="btn btn-yellow" onclick="triggerRecovery('system_cleanup')">Emergency Cleanup</button>
                    <button class="btn btn-purple" onclick="triggerRecovery('websocket_reset')">Reset WebSockets</button>
                </div>
            </div>
        </div>
    '''
    
    # Find where to insert monitoring content
    ai_div_end = content.find('</div>', content.find('<div id="ai" class="tab-content">'))
    if ai_div_end != -1:
        # Find the actual end of the AI div
        div_count = 1
        search_pos = content.find('<div id="ai" class="tab-content">') + len('<div id="ai" class="tab-content">')
        
        while div_count > 0 and search_pos < len(content):
            next_div_open = content.find('<div', search_pos)
            next_div_close = content.find('</div>', search_pos)
            
            if next_div_close != -1 and (next_div_open == -1 or next_div_close < next_div_open):
                div_count -= 1
                search_pos = next_div_close + 6
                if div_count == 0:
                    ai_div_end = search_pos
            elif next_div_open != -1:
                div_count += 1
                search_pos = next_div_open + 4
            else:
                break
        
        content = content[:ai_div_end] + '\n        ' + monitoring_content + content[ai_div_end:]
    
    # Write the modified content
    with open(UI_FILE, 'w') as f:
        f.write(content)
    
    return True

def main():
    print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                  PHOENIX PRO ELITE - PHASE 2C                   ‚ïë
‚ïë               Live Features & Monitoring                         ‚ïë
‚ïë                    üîî GOING LIVE üîî                             ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    print("üîç Phase 2C: Adding live features and monitoring...")
    
    # Check if previous phases exist
    if not UI_FILE.exists():
        print("‚ùå UI file not found!")
        print(f"   Please run previous phases first and ensure {UI_FILE} exists")
        return False
    
    # Check for Phase 2B components
    with open(UI_FILE, 'r') as f:
        content = f.read()
    
    if "class APIIntegratedUIState" not in content:
        print("‚ùå Phase 2B components not found!")
        print("   Please run Phase 2B first to add API integrations")
        return False
    
    print("‚úÖ Previous phases detected")
    
    # Backup current file
    if not backup_ui_file():
        return False
    
    # Modify the UI file
    print("üîß Adding live features functionality...")
    if not modify_ui_file_for_live_features():
        print("‚ùå Failed to modify UI file")
        return False
    
    # Add monitoring tab
    print("üìä Adding monitoring dashboard...")
    if not add_monitoring_tab():
        print("‚ö†Ô∏è Could not add monitoring tab (non-critical)")
    
    print()
    print("‚úÖ PHASE 2C INSTALLATION COMPLETE!")
    print("==================================")
    print()
    print("üîî ADDED LIVE FEATURES:")
    print("   üì° Real-time WebSocket communication")
    print("   üîÑ Auto-reconnect with exponential backoff")
    print("   üìä Live system monitoring threads")
    print("   ü§ñ Bot health monitoring")
    print("   üîî Live alerts banner and panel")
    print("   üíì Heartbeat and connection health")
    print()
    print("   üìà Live Monitoring:")
    print("     - CPU, Memory, Disk usage tracking")
    print("     - WebSocket connection monitoring")
    print("     - Bot performance scoring")
    print("     - Automated threshold alerts")
    print()
    print("   üö® Auto-Recovery System:")
    print("     - Critical alert auto-response")
    print("     - Bot restart automation")
    print("     - System cleanup triggers")
    print("     - WebSocket reset capabilities")
    print()
    print("   üîß New API Endpoints:")
    print("     - /api/ui/alerts/live")
    print("     - /api/ui/monitoring/status")
    print("     - /api/ui/monitoring/toggle")
    print("     - /api/ui/recovery/trigger")
    print("     - /api/ui/performance/baseline")
    print()
    print("   üìä Enhanced UI:")
    print("     - Live alerts banner (top)")
    print("     - Live status bar (bottom)")
    print("     - Monitoring dashboard tab")
    print("     - Recovery controls")
    print("     - Real-time metric updates")
    print()
    print("üöÄ RESTART YOUR UI:")
    print("   cd /root/phoenix-pro-elite/ui")
    print("   python3 app.py")
    print()
    print("üéØ READY FOR PHASE 2D: Advanced UI!")
    
    return True

if __name__ == "__main__":
    main()
    print
